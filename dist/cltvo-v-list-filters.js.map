{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cltvo-v-list-filters.js","webpack:///webpack/bootstrap c94877b6b373cf5780f7","webpack:///./src/list-filters.js","webpack:///external \"coral-std-library\"","webpack:///external \"lodash.debounce\"","webpack:///external \"ramda\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","./src/list-filters.js","listFilters","isStringArray","isPathInObjArray","isPath","undefined","_lodash","_lodash2","obj","default","_coralStdLibrary","R","data","filters","filter_by","previous_filter","search","previous_search","filtered_list","memorized_filters","computed","pre_mapped_list","preMapper","list","ready","filterList","methods","path","pathOr","length","indexOf","multiTextFilter2","watch","0","1","2"],"mappings":"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","file":"cltvo-v-list-filters.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"coral-std-library\"), require(\"lodash.debounce\"), require(\"ramda\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"coral-std-library\", \"lodash.debounce\", \"ramda\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mylib\"] = factory(require(\"coral-std-library\"), require(\"lodash.debounce\"), require(\"ramda\"));\n\telse\n\t\troot[\"mylib\"] = factory(root[\"coral-std-library\"], root[\"lodash.debounce\"], root[\"ramda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"coral-std-library\"), require(\"lodash.debounce\"), require(\"ramda\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"coral-std-library\", \"lodash.debounce\", \"ramda\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mylib\"] = factory(require(\"coral-std-library\"), require(\"lodash.debounce\"), require(\"ramda\"));\n\telse\n\t\troot[\"mylib\"] = factory(root[\"coral-std-library\"], root[\"lodash.debounce\"], root[\"ramda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/list-filters.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/list-filters.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.listFilters = exports.isStringArray = exports.isPathInObjArray = exports.isPath = undefined;\n\nvar _lodash = __webpack_require__(1);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _coralStdLibrary = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar R = __webpack_require__(2);\n\n\n/**\n * Mixin: listFilter\n * \n * V 1.1.2\n * \n * Para información sobre los tipos descritos aquí, revisar readme.md\n * @type {Object}\n */\n\n// isPath :: Path [string] -> String search -> Boolean\nvar isPath = exports.isPath = _coralStdLibrary.pathHasString;\n\n// isPathInObjArray :: Path [String path_to_array]  -> Path [String path_to_text] -> String search -> Boolean\nvar isPathInObjArray = exports.isPathInObjArray = _coralStdLibrary.stringInPathOfObjArray;\n\n// isStringArray :: Path [String]  -> String search -> Boolean\nvar isStringArray = exports.isStringArray = _coralStdLibrary.substringInStringArray;\n\n//Como hacer otros filtros\n//Crear una función que al pasarse al array filters, reciba un String y un Objeto y devuelva un Objeto\n//  String search -> {*}  -> Boolean\n//  \nvar listFilters = exports.listFilters = {\n    data: function data() {\n        return {\n            // list: [],//definir en el componenten o si se usa en una instancia Root de Vue\n            filters: {}, // type FilterSpec, to be defined on receiver component\n            filter_by: '', // type FilterBy,\n            previous_filter: '',\n            search: '',\n            previous_search: '',\n            filtered_list: [],\n            memorized_filters: {} //tenemos que generar el key del array usando todos los parametros de la busqueda para poder diferenciar las otras posibilidades, por ahora son filter_by y search, por lo tanto nuesto objeto se debe ver así\n            //{\n            //  filter_by_${this.filter_by}$search_${this.search} : []\n            //}\n        };\n    },\n\n\n    computed: {\n        pre_mapped_list: function pre_mapped_list() {\n            if (typeof this.preMapper === 'function') {\n                return this.preMapper(this.list);\n            }\n            return this.list;\n        }\n    },\n\n    ready: function ready() {\n        this.filterList();\n    },\n\n\n    methods: {\n        filterList: function filterList() {\n            var filters = R.path([this.filter_by, 'filters'], this.filters);\n            //Optimización: memoización            \n            var filtered_list = R.pathOr([], ['memorized_filters', 'filter_by_' + this.filter_by + '$search_' + this.search], this);\n\n            if (filtered_list.length !== 0) {\n                this.filtered_list = filtered_list;\n                return;\n            }\n\n            if (filters !== undefined && this.search !== '' && this.search.length >= 2) {\n\n                //Optimización: usando previous_search y previous_filter\n                var list = this.pre_mapped_list;\n                if (this.search.indexOf(this.previous_search) === 0 && this.previous_search !== '' && this.previous_filter === this.filter_by) {\n                    //si la busqueda es un refinamiento de la busqueda anterior i.e. Primero se busca \"di\" y luego \"diego\", entonces iteramos sobre la lista previamente filtrada, de otro modo, iteramos sobre la lista original completa\n                    list = this.filtered_list;\n                }\n\n                //filtrado\n                filtered_list = (0, _coralStdLibrary.multiTextFilter2)(filters, this.search, list || []);\n                this.filtered_list = filtered_list;\n                this.memorized_filters['filter_by_' + this.filter_by + '$search_' + this.search] = filtered_list;\n            } else {\n                this.filtered_list = this.pre_mapped_list || [];\n            }\n\n            //actualización de la búsqueda previa\n            this.previous_search = this.search;\n            // console.log(\"this.previous_search\", this.previous_search);\n            this.previous_filter = this.filter_by;\n        }\n    },\n\n    watch: {\n        list: function list() {\n            //al actualizarse la lista original tenemos que resetar todo el estado que nos permite optimizar las búsquedas\n\n            this.memorized_filters = {};\n            this.previous_search = '';\n            this.filterList();\n        },\n        pre_mapped_list: function pre_mapped_list() {\n            this.filterList();\n        },\n        filter_by: function filter_by() {\n            this.filterList();\n        },\n\n\n        search: (0, _lodash2.default)(function () {\n            this.filterList();\n        }, 100)\n    }\n};\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n\n/***/ 2:\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// cltvo-v-list-filters.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/list-filters.js\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c94877b6b373cf5780f7","const R = require('ramda')\nimport debounce from 'lodash.debounce'\nimport {multiTextFilter2, pathHasString, stringInPathOfObjArray, substringInStringArray} from 'coral-std-library'\n\n/**\n * Mixin: listFilter\n * \n * V 1.1.2\n * \n * Para información sobre los tipos descritos aquí, revisar readme.md\n * @type {Object}\n */\n\n\n// isPath :: Path [string] -> String search -> Boolean\nexport const isPath = pathHasString\n\n// isPathInObjArray :: Path [String path_to_array]  -> Path [String path_to_text] -> String search -> Boolean\nexport const isPathInObjArray = stringInPathOfObjArray\n\n// isStringArray :: Path [String]  -> String search -> Boolean\nexport const isStringArray = substringInStringArray\n\n//Como hacer otros filtros\n//Crear una función que al pasarse al array filters, reciba un String y un Objeto y devuelva un Objeto\n//  String search -> {*}  -> Boolean\n//  \nexport const listFilters = {\n    data() {\n        return {\n            // list: [],//definir en el componenten o si se usa en una instancia Root de Vue\n            filters: {},// type FilterSpec, to be defined on receiver component\n            filter_by: '',// type FilterBy,\n            previous_filter: '',\n            search: '',\n            previous_search: '',\n            filtered_list: [],\n            memorized_filters: {}//tenemos que generar el key del array usando todos los parametros de la busqueda para poder diferenciar las otras posibilidades, por ahora son filter_by y search, por lo tanto nuesto objeto se debe ver así\n                //{\n                //  filter_by_${this.filter_by}$search_${this.search} : []\n                //}\n        }\n    },\n\n\n    computed: {\n        pre_mapped_list() {\n             if(typeof this.preMapper === 'function') {\n                return this.preMapper(this.list)\n             }\n            return this.list\n        },\n    },\n\n    ready() {\n        this.filterList()\n    },\n\n    methods: {\n        filterList: function() {\n            let filters = R.path([this.filter_by, 'filters'], this.filters)\n            //Optimización: memoización            \n            let filtered_list = R.pathOr([], ['memorized_filters', `filter_by_${this.filter_by}$search_${this.search}`], this)\n\n            if (filtered_list.length !== 0) {\n                this.filtered_list = filtered_list\n                return\n            }\n            \n            if (filters !== undefined && this.search !== '' &&  this.search.length >= 2) {\n                \n                //Optimización: usando previous_search y previous_filter\n                let list =  this.pre_mapped_list\n                if (this.search.indexOf(this.previous_search) === 0 && this.previous_search !== '' && this.previous_filter === this.filter_by) {//si la busqueda es un refinamiento de la busqueda anterior i.e. Primero se busca \"di\" y luego \"diego\", entonces iteramos sobre la lista previamente filtrada, de otro modo, iteramos sobre la lista original completa\n                    list = this.filtered_list \n                } \n\n                //filtrado\n                filtered_list = multiTextFilter2(filters, this.search, list || [])\n                this.filtered_list = filtered_list\n                this.memorized_filters[`filter_by_${this.filter_by}$search_${this.search}`] = filtered_list\n\n            } else {\n                this.filtered_list = this.pre_mapped_list || []\n            }\n\n            //actualización de la búsqueda previa\n            this.previous_search = this.search\n            // console.log(\"this.previous_search\", this.previous_search);\n            this.previous_filter = this.filter_by\n        }\n    },\n\n    watch: {\n        list() {//al actualizarse la lista original tenemos que resetar todo el estado que nos permite optimizar las búsquedas\n            \n            this.memorized_filters = {}\n            this.previous_search = ''\n            this.filterList()\n        },\n\n        pre_mapped_list() {\n            this.filterList()\n        },\n\n        filter_by() {\n            this.filterList()\n        },\n\n        search: debounce(function () {\n            this.filterList()\n        }, 100)\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/list-filters.js","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"coral-std-library\"\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash.debounce\"\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ramda\"\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}